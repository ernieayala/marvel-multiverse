/**
 * Extend the base Actor document by defining a custom roll data structure which is ideal for the Simple system.
 * @extends {Actor}
 */
class MarvelMultiverseActor extends Actor {
  /** @override */
  prepareData() {
    // Prepare data for the actor. Calling the super version of this executes
    // the following, in order: data reset (to clear active effects),
    // prepareBaseData(), prepareEmbeddedDocuments() (including active effects),
    // prepareDerivedData().
    super.prepareData();
  }

  /** @override */
  prepareBaseData() {
    // Data modifications in this step occur before processing embedded
    // documents or derived data.
  }

  /**
   * @override
   * Augment the actor source data with additional dynamic data that isn't 
   * handled by the actor's DataModel. Data calculated in this step should be
   * available both inside and outside of character sheets (such as if an actor
   * is queried and has a roll executed directly from it).
   */
  prepareDerivedData() {
    const actorData = this;
    actorData.flags.MarvelMultiverse || {};
  }

  /**
   * 
   * @override
   * Augment the actor's default getRollData() method by appending the data object
   * generated by the its DataModel's getRollData(), or null. This polymorphic 
   * approach is useful when you have actors & items that share a parent Document, 
   * but have slightly different data preparation needs.
   */
  getRollData() {
    return { ...super.getRollData(), ...this.system.getRollData?.() ?? null };
  }

}

/**
 * Extend the basic Item with some very simple modifications.
 * @extends {Item}
 */
let MarvelMultiverseItem$1 = class MarvelMultiverseItem extends Item {
  /**
   * Augment the basic Item data model with additional dynamic data.
   */
  prepareData() {
    // As with the actor class, items are documents that can have their data
    // preparation methods overridden (such as prepareBaseData()).
    super.prepareData();
  }

  /**
   * Prepare a data object which defines the data schema used by dice roll commands against this Item
   * @override
   */
  getRollData() {
    // Starts off by populating the roll data with `this.system`
    const rollData = { ...super.getRollData() };

    // Quit early if there's no parent actor
    if (!this.actor) return rollData;

    // If present, add the actor's roll data
    rollData.actor = this.actor.getRollData();

    return rollData;
  }

  /**
   * Handle clickable rolls.
   * @param {Event} event   The originating click event
   * @private
   */
  async roll() {
    const item = this;

    // Initialize chat data.
    const speaker = ChatMessage.getSpeaker({ actor: this.actor });
    const rollMode = game.settings.get('core', 'rollMode');
    const label = `[${item.type}] ${item.name}`;

    // If there's no roll data, send a chat message.
    if (!this.system.formula) {
      ChatMessage.create({
        speaker: speaker,
        rollMode: rollMode,
        flavor: label,
        content: item.system.description ?? '',
      });
    }
    // Otherwise, create a roll and send a chat message from it.
    else {
      // Retrieve roll data.
      const rollData = this.getRollData();

      // Invoke the roll and submit it to chat.
      const roll = new Roll(rollData.formula, rollData.actor);
      // If you need to store the value first, uncomment the next line.
      // const result = await roll.evaluate();
      roll.toMessage({
        speaker: speaker,
        rollMode: rollMode,
        flavor: label,
      });
      return roll;
    }
  }
};

/**
 * Manage Active Effect instances through an Actor or Item Sheet via effect control buttons.
 * @param {MouseEvent} event      The left-click event on the effect control
 * @param {Actor|Item} owner      The owning document which manages this effect
 */
function onManageActiveEffect(event, owner) {
  event.preventDefault();
  const a = event.currentTarget;
  const li = a.closest('li');
  const effect = li.dataset.effectId
    ? owner.effects.get(li.dataset.effectId)
    : null;
  switch (a.dataset.action) {
    case 'create':
      return owner.createEmbeddedDocuments('ActiveEffect', [
        {
          name: game.i18n.format('DOCUMENT.New', {
            type: game.i18n.localize('DOCUMENT.ActiveEffect'),
          }),
          icon: 'icons/svg/aura.svg',
          origin: owner.uuid,
          'duration.rounds':
            li.dataset.effectType === 'temporary' ? 1 : undefined,
          disabled: li.dataset.effectType === 'inactive',
        },
      ]);
    case 'edit':
      return effect.sheet.render(true);
    case 'delete':
      return effect.delete();
    case 'toggle':
      return effect.update({ disabled: !effect.disabled });
  }
}

/**
 * Prepare the data structure for Active Effects which are currently embedded in an Actor or Item.
 * @param {ActiveEffect[]} effects    A collection or generator of Active Effect documents to prepare sheet data for
 * @return {object}                   Data for rendering
 */
function prepareActiveEffectCategories(effects) {
  // Define effect header categories
  const categories = {
    temporary: {
      type: 'temporary',
      label: game.i18n.localize('MARVEL_MULTIVERSE.Effect.Temporary'),
      effects: [],
    },
    passive: {
      type: 'passive',
      label: game.i18n.localize('MARVEL_MULTIVERSE.Effect.Passive'),
      effects: [],
    },
    inactive: {
      type: 'inactive',
      label: game.i18n.localize('MARVEL_MULTIVERSE.Effect.Inactive'),
      effects: [],
    },
  };

  // Iterate over active effects, classifying them into categories
  for (let e of effects) {
    if (e.disabled) categories.inactive.effects.push(e);
    else if (e.isTemporary) categories.temporary.effects.push(e);
    else categories.passive.effects.push(e);
  }
  return categories;
}

/**
 * Extend the basic ActorSheet with some very simple modifications
 * @extends {ActorSheet}
 */
class MarvelMultiverseActorSheet extends ActorSheet {
  /** @override */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ['marvel-multiverse', 'sheet', 'actor'],
      width: 600,
      height: 600,
      tabs: [
        {
          navSelector: '.sheet-tabs',
          contentSelector: '.sheet-body',
          initial: 'traits',
        },
      ],
    });
  }

  /** @override */
  get template() {
    return `systems/marvel-multiverse/templates/actor/actor-${this.actor.type}-sheet.hbs`;
  }

  /* -------------------------------------------- */

  /** @override */
  getData() {
    // Retrieve the data structure from the base sheet. You can inspect or log
    // the context variable to see the structure, but some key properties for
    // sheets are the actor object, the data object, whether or not it's
    // editable, the items array, and the effects array.
    const context = super.getData();

    // Use a safe clone of the actor data for further operations.
    const actorData = context.data;

    // Add the actor's data to context.data for easier access, as well as flags.
    context.system = actorData.system;
    context.flags = actorData.flags;

    // Prepare character data and items.
    if (actorData.type == 'character') {
      this._prepareItems(context);
      this._prepareCharacterData(context);
    }

    // Prepare NPC data and items.
    if (actorData.type == 'npc') {
      this._prepareItems(context);
    }

    // Add roll data for TinyMCE editors.
    context.rollData = context.actor.getRollData();

    // Prepare active effects
    context.effects = prepareActiveEffectCategories(
      // A generator that returns all effects stored on the actor
      // as well as any items
      this.actor.allApplicableEffects()
    );

    return context;
  }

  /**
   * Organize and classify Items for Character sheets.
   *
   * @param {Object} actorData The actor to prepare.
   *
   * @return {undefined}
   */
  _prepareCharacterData(context) {
    // Handle ability scores.
    // for (let [k, v] of Object.entries(context.system.abilities)) {
    //   v.label = game.i18n.localize(CONFIG.MARVEL_MULTIVERSE.abilities[k]) ?? k;
    // }
  }

  /**
   * Organize and classify Items for Character sheets.
   *
   * @param {Object} actorData The actor to prepare.
   *
   * @return {undefined}
   */
  _prepareItems(context) {
    // Initialize containers.
    const gear = [];
    const traits = [];
    const origins = [];
    const tags = [];
    const powers = {
      "Basic": [],
      "Elemental Control": [],
      "Illusion": [],
      "Magic (Chaotic)": [],
      "Magic (Cursed)": [],
      "Magic (Sorcerous)": [],
      "Martial Arts": [],
      "Melee Weapons": [],
      "Omniversal Travel (Dimensionol)": [],
      "Omniversal Travel (Mulliversal)": [],
      "Omniversal Travel (Time)": [],
      "Phasing": [],
      "Plasticity": [],
      "Power Cantrol": [],
      "Ranged Weapons": [],
      "Resize": [],
      "Shield Bearer": [],
      "Spider-Powers": [],
      "Super-Speed": [],
      "Super-Strength": [],
      "Tactics": [],
      "Telekinesis": [],
      "Telepathy": [],
      "Teleportation": [],
      "Weather Control": [],
    };

    // Iterate through items, allocating to containers
    for (let i of context.items) {
      i.img = i.img || Item.DEFAULT_ICON;
      // Append to gear.
      if (i.type === 'item') {
        gear.push(i);
      }
      // Append to traits.
      else if (i.type === 'trait') {
        traits.push(i);
      }
       // Append to tags.
       else if (i.type === 'tag') {
        tags.push(i);
      }
      // Append to tags.
      else if (i.type === 'origin') {
        origins.push(i);
      }
      // Append to powers.
      else if (i.type === 'power') {
        if (i.system.powerSet != undefined) {
          powers[i.system.powerSet].push(i);
        }
      }
    }

    // Assign and return
    context.gear = gear;
    context.traits = traits;
    context.tags = tags;
    context.powers = powers;
    context.origins = origins;
  }

  /* -------------------------------------------- */

  /** @override */
  activateListeners(html) {
    super.activateListeners(html);

    // Render the item sheet for viewing/editing prior to the editable check.
    html.on('click', '.item-edit', (ev) => {
      const li = $(ev.currentTarget).parents('.item');
      const item = this.actor.items.get(li.data('itemId'));
      item.sheet.render(true);
    });

    // -------------------------------------------------------------
    // Everything below here is only needed if the sheet is editable
    if (!this.isEditable) return;

    // Add Inventory Item
    html.on('click', '.item-create', this._onItemCreate.bind(this));

    // Delete Inventory Item
    html.on('click', '.item-delete', (ev) => {
      const li = $(ev.currentTarget).parents('.item');
      const item = this.actor.items.get(li.data('itemId'));
      item.delete();
      li.slideUp(200, () => this.render(false));
    });

    // Active Effect management
    html.on('click', '.effect-control', (ev) => {
      const row = ev.currentTarget.closest('li');
      const document =
        row.dataset.parentId === this.actor.id
          ? this.actor
          : this.actor.items.get(row.dataset.parentId);
      onManageActiveEffect(ev, document);
    });

    // Rollable abilities.
    html.on('click', '.rollable', this._onRoll.bind(this));

    // Drag events for macros.
    if (this.actor.isOwner) {
      let handler = (ev) => this._onDragStart(ev);
      html.find('li.item').each((i, li) => {
        if (li.classList.contains('inventory-header')) return;
        li.setAttribute('draggable', true);
        li.addEventListener('dragstart', handler, false);
      });
    }
  }

  /**
   * Handle creating a new Owned Item for the actor using initial data defined in the HTML dataset
   * @param {Event} event   The originating click event
   * @private
   */
  async _onItemCreate(event) {
    event.preventDefault();
    const header = event.currentTarget;
    // Get the type of item to create.
    const type = header.dataset.type;
    // Grab any data associated with this control.
    const data = duplicate(header.dataset);
    // Initialize a default name.
    const name = `New ${type.capitalize()}`;
    // Prepare the item object.
    const itemData = {
      name: name,
      type: type,
      system: data,
    };
    // Remove the type from the dataset since it's in the itemData.type prop.
    delete itemData.system['type'];

    // Finally, create the item!
    return await Item.create(itemData, { parent: this.actor });
  }

  /**
   * Handle clickable rolls.
   * @param {Event} event   The originating click event
   * @private
   */
  _onRoll(event) {
    event.preventDefault();
    const element = event.currentTarget;
    const dataset = element.dataset;

    // Handle item rolls.
    if (dataset.rollType) {
      if (dataset.rollType == 'item') {
        const itemId = element.closest('.item').dataset.itemId;
        const item = this.actor.items.get(itemId);
        if (item) return item.roll();
      }
    }

    // Handle rolls that supply the formula directly.
    if (dataset.roll) {
      let label = dataset.label ? `[ability] ${dataset.label}` : '';
      let roll = new Roll(dataset.roll, this.actor.getRollData());
      roll.toMessage({
        speaker: ChatMessage.getSpeaker({ actor: this.actor }),
        flavor: label,
        rollMode: game.settings.get('core', 'rollMode'),
      });
      return roll;
    }
  }
}

/**
 * Extend the basic ItemSheet with some very simple modifications
 * @extends {ItemSheet}
 */
class MarvelMultiverseItemSheet extends ItemSheet {
  /** @override */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ['marvel-multiverse', 'sheet', 'item'],
      width: 520,
      height: 480,
      tabs: [
        {
          navSelector: '.sheet-tabs',
          contentSelector: '.sheet-body',
          initial: 'description',
        },
      ],
    });
  }

  /** @override */
  get template() {
    const path = 'systems/marvel-multiverse/templates/item';
    // Return a single sheet for all item types.
    // return `${path}/item-sheet.hbs`;

    // Alternatively, you could use the following return statement to do a
    // unique item sheet by type, like `weapon-sheet.hbs`.
    return `${path}/item-${this.item.type}-sheet.hbs`;
  }

  /* -------------------------------------------- */

  /** @override */
  getData() {
    // Retrieve base data structure.
    const context = super.getData();

    // Use a safe clone of the item data for further operations.
    const itemData = context.data;

    // Retrieve the roll data for TinyMCE editors.
    context.rollData = this.item.getRollData();

    // Add the item's data to context.data for easier access, as well as flags.
    context.system = itemData.system;
    context.flags = itemData.flags;

    // Prepare active effects for easier access
    context.effects = prepareActiveEffectCategories(this.item.effects);

    return context;
  }

  /* -------------------------------------------- */

  /** @override */
  activateListeners(html) {
    super.activateListeners(html);

    // Everything below here is only needed if the sheet is editable
    if (!this.isEditable) return;

    // Roll handlers, click handlers, etc. would go here.

    // Active Effect management
    html.on('click', '.effect-control', (ev) =>
      onManageActiveEffect(ev, this.item)
    );
  }
}

/**
 * Define a set of template paths to pre-load
 * Pre-loaded templates are compiled and cached for fast access when rendering
 * @return {Promise}
 */
const preloadHandlebarsTemplates = async function () {
  return loadTemplates([
    // Actor partials.
    'systems/marvel-multiverse/templates/actor/parts/actor-tags.hbs',
    'systems/marvel-multiverse/templates/actor/parts/actor-traits.hbs',
    'systems/marvel-multiverse/templates/actor/parts/actor-items.hbs',,
    'systems/marvel-multiverse/templates/actor/parts/actor-details.hbs',
    'systems/marvel-multiverse/templates/actor/parts/actor-origins.hbs',
    'systems/marvel-multiverse/templates/actor/parts/actor-powers.hbs',
    'systems/marvel-multiverse/templates/actor/parts/actor-effects.hbs',
    // Item partials
    'systems/marvel-multiverse/templates/item/parts/item-effects.hbs',
  ]);
};

const MARVEL_MULTIVERSE$1 = {};

/**
 * The set of Ability Scores used within the system.
 * @type {Object}
 */
MARVEL_MULTIVERSE$1.abilities = {
  mel: 'MARVEL_MULTIVERSE.Ability.Mel.long',
  agl: 'MARVEL_MULTIVERSE.Ability.Agl.long',
  res: 'MARVEL_MULTIVERSE.Ability.Res.long',
  vig: 'MARVEL_MULTIVERSE.Ability.Vig.long',
  ego: 'MARVEL_MULTIVERSE.Ability.Ego.long',
  log: 'MARVEL_MULTIVERSE.Ability.Log.long',
};

MARVEL_MULTIVERSE$1.abilityAbbreviations = {
  mel: 'MARVEL_MULTIVERSE.Ability.Mel.abbr',
  agl: 'MARVEL_MULTIVERSE.Ability.Agl.abbr',
  res: 'MARVEL_MULTIVERSE.Ability.Res.abbr',
  vig: 'MARVEL_MULTIVERSE.Ability.Vig.abbr',
  ego: 'MARVEL_MULTIVERSE.Ability.Ego.abbr',
  log: 'MARVEL_MULTIVERSE.Ability.Log.abbr',
};

MARVEL_MULTIVERSE$1.MARVEL_RESULTS = {
  1: { label: "MARVEL_MULTIVERSE.MarvelResult.M", image: `systems/marvel-multiverse/icons/marvel-1.svg`},
  2: { label: "MARVEL_MULTIVERSE.MarvelResult.2", image: `systems/marvel-multiverse/icons/marvel-2.svg`},
  3: { label: "MARVEL_MULTIVERSE.MarvelResult.3", image: `systems/marvel-multiverse/icons/marvel-3.svg`},
  4: { label: "MARVEL_MULTIVERSE.MarvelResult.4", image: `systems/marvel-multiverse/icons/marvel-4.svg`},
  5: { label: "MARVEL_MULTIVERSE.MarvelResult.5", image: `systems/marvel-multiverse/icons/marvel-5.svg`},
  6: { label: "MARVEL_MULTIVERSE.MarvelResult.6", image: `systems/marvel-multiverse/icons/marvel-6.svg`},
};


MARVEL_MULTIVERSE$1.DICE_RESULTS = {
  1: { label: "MARVEL_MULTIVERSE.DiceResult.1", image: `systems/marvel-multiverse/icons/1.svg`},
  2: { label: "MARVEL_MULTIVERSE.DiceResult.2", image: `systems/marvel-multiverse/icons/2.svg`},
  3: { label: "MARVEL_MULTIVERSE.DiceResult.3", image: `systems/marvel-multiverse/icons/3.svg`},
  4: { label: "MARVEL_MULTIVERSE.DiceResult.4", image: `systems/marvel-multiverse/icons/4.svg`},
  5: { label: "MARVEL_MULTIVERSE.DiceResult.5", image: `systems/marvel-multiverse/icons/5.svg`},
  6: { label: "MARVEL_MULTIVERSE.DiceResult.6", image: `systems/marvel-multiverse/icons/6.svg`},
};

class MarvelMultiverseActorBase extends foundry.abstract.TypeDataModel {

  static defineSchema() {
    const fields = foundry.data.fields;
    const requiredInteger = { required: true, nullable: false, integer: true };
    const schema = {};

    schema.health = new fields.SchemaField({
      value: new fields.NumberField({ ...requiredInteger, initial: 10, min: 0 }),
      max: new fields.NumberField({ ...requiredInteger, initial: 10 })
    });
    schema.focus = new fields.SchemaField({
      value: new fields.NumberField({ ...requiredInteger, initial: 5, min: 0 }),
      max: new fields.NumberField({ ...requiredInteger, initial: 5 })
    });
    schema.karma = new fields.SchemaField({
      value: new fields.NumberField({ ...requiredInteger, initial: 5, min: 0 }),
      max: new fields.NumberField({ ...requiredInteger, initial: 5 })
    });

    schema.codename = new fields.StringField({ required: true, blank: true }); // equivalent to passing ({initial: ""}) for StringFields
    schema.realname = new fields.StringField({ required: true, blank: true }); // equivalent to passing ({initial: ""}) for StringFields
    schema.height = new fields.StringField({ required: true, blank: true }); // equivalent to passing ({initial: ""}) for StringFields
    schema.weight = new fields.StringField({ required: true, blank: true }); // equivalent to passing ({initial: ""}) for StringFields
    schema.gender = new fields.StringField({ required: true, blank: true }); // equivalent to passing ({initial: ""}) for StringFields
    schema.eyes = new fields.StringField({ required: true, blank: true }); // equivalent to passing ({initial: ""}) for StringFields
    schema.hair = new fields.StringField({ required: true, blank: true }); // equivalent to passing ({initial: ""}) for StringFields
    schema.size = new fields.StringField({ required: true, initial: "Average" }); // equivalent to passing ({initial: ""}) for StringFields
    schema.distinguishingFeatures = new fields.StringField({ required: true, blank: true }); // equivalent to passing ({initial: ""}) for StringFields
    schema.teams = new fields.StringField({ required: true, blank: true }); // equivalent to passing ({initial: ""}) for StringFields
    schema.history = new fields.StringField({ required: true, blank: true }); // equivalent to passing ({initial: ""}) for StringFields
    schema.personality = new fields.StringField({ required: true, blank: true }); // equivalent to passing ({initial: ""}) for StringFields
    
    return schema;
  }
}

class MarvelMultiverseCharacter extends MarvelMultiverseActorBase {

  static defineSchema() {
    const fields = foundry.data.fields;
    const requiredInteger = { required: true, nullable: false, integer: true };
    const schema = super.defineSchema();

    schema.attributes = new fields.SchemaField({
      rank: new fields.SchemaField({
        value: new fields.NumberField({ ...requiredInteger, initial: 1 })
      }),
    });

    // Iterate over ability names and create a new SchemaField for each.
    schema.abilities = new fields.SchemaField(Object.keys(CONFIG.MARVEL_MULTIVERSE.abilities).reduce((obj, ability) => {
      obj[ability] = new fields.SchemaField({
        value: new fields.NumberField({ ...requiredInteger, initial: 10, min: 0 }),
        mod: new fields.NumberField({ ...requiredInteger, initial: 0, min: 0 }),
        label: new fields.StringField({ required: true, blank: true })
      });
      return obj;
    }, {}));

    return schema;
  }

  prepareDerivedData() {
    // Loop through ability scores, and add their modifiers to our sheet output.
    for (const key in this.abilities) {
      // Calculate the modifier using mmrpg rules.
      this.abilities[key].mod = this.abilities[key].value;
      // Handle ability label localization.
      this.abilities[key].label = game.i18n.localize(CONFIG.MARVEL_MULTIVERSE.abilities[key]) ?? key;
    }
  }

  getRollData() {
    const data = {};

    // Copy the ability scores to the top rank, so that rolls can use
    // formulas like `@mel.mod + 4`.
    if (this.abilities) {
      for (let [k,v] of Object.entries(this.abilities)) {
        data[k] = foundry.utils.deepClone(v);
      }
    }

    data.rank = this.attributes.rank.value;

    return data
  }
}

class MarvelMultiverseNPC extends MarvelMultiverseActorBase {

  static defineSchema() {
    const fields = foundry.data.fields;
    const requiredInteger = { required: true, nullable: false, integer: true };
    const schema = super.defineSchema();

    schema.cr = new fields.NumberField({ ...requiredInteger, initial: 1, min: 0 });
    schema.xp = new fields.NumberField({ ...requiredInteger, initial: 0, min: 0 });
    
    return schema
  }

  prepareDerivedData() {
    this.xp = this.cr * this.cr * 100;
  }
}

class MarvelMultiverseItemBase extends foundry.abstract.TypeDataModel {

  static defineSchema() {
    const fields = foundry.data.fields;
    const schema = {};

    schema.description = new fields.StringField({ required: true, blank: true });

    return schema;
  }
}

class MarvelMultiverseItem extends MarvelMultiverseItemBase {

  static defineSchema() {
    const fields = foundry.data.fields;
    const requiredInteger = { required: true, nullable: false, integer: true };
    const schema = super.defineSchema();

    schema.quantity = new fields.NumberField({ ...requiredInteger, initial: 1, min: 1 });
    schema.weight = new fields.NumberField({ required: true, nullable: false, initial: 0, min: 0 });

    // Break down roll formula into three independent fields
    schema.roll = new fields.SchemaField({
      diceNum: new fields.NumberField({ ...requiredInteger, initial: 1, min: 1 }),
      diceSize: new fields.StringField({ initial: "d20" }),
      diceBonus: new fields.StringField({ initial: "+@str.mod+ceil(@rank / 2)" })
    });

    schema.formula = new fields.StringField({ blank: true });

    return schema;
  }

  prepareDerivedData() {
    // Build the formula dynamically using string interpolation
    const roll = this.roll;

    this.formula = `${roll.diceNum}${roll.diceSize}${roll.diceBonus}`;
  }
}

class MarvelMultiverseOccupation extends MarvelMultiverseItemBase {}

class MarvelMultiverseOrigin extends MarvelMultiverseItemBase {
    static defineSchema() {
        const fields = foundry.data.fields;
        const schema = super.defineSchema();
    
        schema.examples = new fields.StringField({ required: true, blank: true });
        schema.suggestedOccupation = new fields.StringField({ required: true, blank: true });

        return schema;
    }
}

class MarvelMultiverseTag extends MarvelMultiverseItemBase {
    static defineSchema() {
        const fields = foundry.data.fields;
        const schema = super.defineSchema();
    
        schema.restriction = new fields.StringField({ required: true, blank: true });
        schema.rarity = new fields.StringField({ required: true, blank: true });
      
        return schema;
      }
}

class MarvelMultiverseTrait extends MarvelMultiverseItemBase {}

class MarvelMultiversePower extends MarvelMultiverseItemBase {

  static defineSchema() {
    const fields = foundry.data.fields;
    const schema = super.defineSchema();

    schema.powerSet = new fields.StringField({ required: true, initial: "Basic" });
    schema.prerequisites = new fields.StringField({ blank: true });
    schema.action = new fields.StringField({ blank: true });
    schema.trigger = new fields.StringField({ blank: true });
    schema.duration = new fields.StringField({ blank: true });
    schema.range = new fields.StringField({ blank: true });
    schema.cost = new fields.StringField({ blank: true });
    schema.effect = new fields.StringField({ blank: true });
    
    return schema;
  }
}

/**
 * Establish each MMRPG dice type here as extensions of DiceTerm.
 * @extends {DiceTerm}
 */
class MarvelDie extends DiceTerm {
      
    constructor(termData) {
        super(termData);
        this.faces = 6;
    }

    /* -------------------------------------------- */
    /** @override */
    static DENOMINATION = "m";

    /** @inheritdoc */
    static MODIFIERS = {
        "r": Die.prototype.reroll,
        "rr": Die.prototype.rerollRecursive,
        "k": Die.prototype.keep,
        "kh": Die.prototype.keep,
        "kl": Die.prototype.keep,
        "d": Die.prototype.drop,
        "dh": Die.prototype.drop,
        "dl": Die.prototype.drop
    }

    /* -------------------------------------------- */
    /** @override */
    get formula() {
        return `${this.number}${this.constructor.DENOMINATION}${this.modifiers.join("")}`;
    }

    /* -------------------------------------------- */
    /** @override */
    evaluate({ minimize = false, maximize = false } = {}) {
        if (this._evaluated) {
            throw new Error(`This ${this.constructor.name} has already been evaluated and is immutable`);
        }

        // Roll the initial number of dice
        for (let n = 1; n <= this.number; n++) {
            this.roll({ minimize, maximize });
        }

        // Apply modifiers
        this._evaluateModifiers();
        this.results.forEach((result) => {
            if(result.result === 1){
                result.count = 6;
            }
        });
        this._evaluated = true;
        this._isMarvel = true;
        return this;
    }

    /* -------------------------------------------- */
    /** @override */
    roll(options) {
        const roll = super.roll(options);
        roll.MARVEL_MULTIVERSE = CONFIG.MARVEL_MULTIVERSE.MARVEL_RESULTS[roll.result];
        return roll;
    }

    /* -------------------------------------------- */
    /** @override */
    getResultLabel(result) {
        const die = CONFIG.MARVEL_MULTIVERSE.MARVEL_RESULTS[result.result];
        return `<img src='${die.image}' title='${game.i18n.localize(die.label)}' alt=''/>`;
    }
}

/**
 * Establish each MMRPG dice type here as extensions of DiceTerm.
 * @extends {DiceTerm}
 */
class SixSidedDie extends DiceTerm {
      
    constructor(termData) {
        super(termData);
        this.faces = 6;
    }

    /* -------------------------------------------- */
    /** @override */
    static DENOMINATION = "6";


    /** @inheritdoc */
    static MODIFIERS = {
        "r": Die.prototype.reroll,
        "rr": Die.prototype.rerollRecursive,
        "k": Die.prototype.keep,
        "kh": Die.prototype.keep,
        "kl": Die.prototype.keep,
        "d": Die.prototype.drop,
        "dh": Die.prototype.drop,
        "dl": Die.prototype.drop
    }

    /* -------------------------------------------- */
    /** @override */
    get formula() {
        return `${this.number}${this.constructor.DENOMINATION}${this.modifiers.join("")}`;
    }


    /* -------------------------------------------- */
    /** @override */
    evaluate({ minimize = false, maximize = false } = {}) {
        if (this._evaluated) {
            throw new Error(`This ${this.constructor.name} has already been evaluated and is immutable`);
        }

        // Roll the initial number of dice
        for (let n = 1; n <= this.number; n++) {
            this.roll({ minimize, maximize });
        }

        // Apply modifiers
        this._evaluateModifiers();

        this._evaluated = true;
        this._isMarvel = true;
        return this;
    }
    roll(options) {
        const roll = super.roll(options);
        roll.MARVEL_MULTIVERSE = CONFIG.MARVEL_MULTIVERSE.DICE_RESULTS[roll.result];
        return roll;
    }

    /* -------------------------------------------- */
    /** @override */
    getResultLabel(result) {
        const die = CONFIG.MARVEL_MULTIVERSE.DICE_RESULTS[result.result];
        return `<img src='${die.image}' title='${game.i18n.localize(die.label)}' alt=''/>`;
    }
}

/**
 * Extend the base Roll document by defining a pool for evaluating rolls with the Marvel DiceTerms.
 * @extends {Roll}
 */
class MarvelMultiverseRoll extends Roll {
    constructor(formula, data, options) {
        super(formula, data, options);
        //additional hook to change options and configuration
        this.MARVEL_MULTIVERSE = { };
        this.terms = this.parseShortHand(this.terms);
        if ( !this.options.configured ) this.configureModifiers();
        this.hasMARVEL_MULTIVERSE = false;
    }



    /* -------------------------------------------- */

    /**
     * Create a MarvelMultiverseRoll from a standard Roll instance.
     * @param {Roll} roll
     * @returns {MarvelMultiverseRoll}
     */
    static fromRoll(roll) {
        const newRoll = new this(roll.formula, roll.data, roll.options);
        Object.assign(newRoll, roll);
        return newRoll;
    }

    /* -------------------------------------------- */

    /**
     * Determine whether a d616 roll should be fast-forwarded, and whether advantage or disadvantage should be applied.
     * @param {object} [options]
     * @param {Event} [options.event]                               The Event that triggered the roll.
     * @param {boolean} [options.edge]                         Is something granting this roll advantage?
     * @param {boolean} [options.trouble]                      Is something granting this roll disadvantage?
     * @param {boolean} [options.fastForward]                       Should the roll dialog be skipped?
     * @returns {{edgeMode: MarvelMultiverseRoll.EDGE_MODE, isFF: boolean}}  Whether the roll is fast-forwarded, and its advantage
     *                                                              mode.
     */
    static determineEdgeMode({event, edge=false, trouble=false, fastForward}={}) {
        const isFF = fastForward ?? (event?.shiftKey || event?.altKey || event?.ctrlKey || event?.metaKey);
        let edgeMode = this.EDGE_MODE.NORMAL;
        if ( edge || event?.altKey ) edgeMode = this.EDGE_MODE.EDGE;
        else if ( trouble || event?.ctrlKey || event?.metaKey ) edgeMode = this.EDGE_MODE.TROUBLE;
        return {isFF: !!isFF, edgeMode};
    }

    /* -------------------------------------------- */

    /**
     * Edge mode of a mmrpg d616 roll
     * @enum {number}
     */
    static EDGE_MODE = {
        NORMAL: 0,
        EDGE: 1,
        TROUBLE: -1
    };

    /* -------------------------------------------- */

    /**
     * The HTML template path used to configure evaluation of this Roll
     * @type {string}
     */
    static EVALUATION_TEMPLATE = "systems/marvel-multiverse/templates/chat/roll-dialog.hbs";


    /**
     * The  template path used to Roll in chat
     * @type {string}
     */
    static CHAT_TEMPLATE = "systems/marvel-multiverse/templates/dice/roll.hbs"
    /* -------------------------------------------- */

    /**
     * Does this roll start with a d6 or dm?
     * @type {boolean}
     */
    get validD616Roll() {
        return (this.terms[0] instanceof Die) && (this.terms[0].faces === 6);
    }

    /* -------------------------------------------- */

    /**
     * A convenience reference for whether this marvel or d6 Roll has edge
     * @type {boolean}
     */
    get hasEdge() {
        return this.options.edgeMode === MarvelMultiverseRoll.EDGE_MODE.EDGE;
    }

    /* -------------------------------------------- */

    /**
     * A convenience reference for whether this marvel or d6 Roll has trouble
     * @type {boolean}
     */
    get hasTrouble() {
        return this.options.edgeMode === MarvelMultiverseRoll.EDGE_MODE.TROUBLE;
    }


    /**
     * Is this roll a fantastic result? Returns undefined if roll isn't evaluated.
     * @type {boolean|void}
     */
    get isFantastic() {
        if ( !this.validD616Roll || !this._evaluated ) return undefined;
        if ( !Number.isNumeric(this.options.fantastic) ) return false;
        if ( this.options.fantastic ) MARVEL_MULTIVERSE.options.fantastic = this.options.fantastic;
        return this.dice[0].total >= this.options.fantastic;
    }


    /* -------------------------------------------- */
    /*  D616 Roll Methods                            */
    /* -------------------------------------------- */

    /**
     * Apply optional modifiers which customize the behavior of the d616term
     * @private
     */
    configureModifiers() {
        const d616 = this.terms[0];
        d616.modifiers = [];

         // Handle Advantage or Disadvantage
        if ( this.hasEdge ) {
            d616.number = 2;
            d616.modifiers.push("kh");
            d616.options.edge = true;
        }
        else if ( this.hasTrouble ) {
            d616.number = 2;
            d616.modifiers.push("kl");
            d616.options.trouble = true;
        }
        else d616.number = 1;
        // Mark configuration as complete
          this.options.configured = true;
    }



    /** @inheritdoc */
    async toMessage(messageData={}, options={}) {

        // Evaluate the roll now so we have the results available to determine whether reliable talent came into play
        if ( !this._evaluated ) await this.evaluate({async: true});

        // Add appropriate edge mode message flavor and mmrpg roll flags
        messageData.flavor = messageData.flavor || this.options.flavor;
        if ( this.hasEdge ) messageData.flavor += ` (${game.i18n.localize("MARVEL_MULTIVERSE.edge")})`;
        else if ( this.hasTrouble ) messageData.flavor += ` (${game.i18n.localize("MARVEL_MULTIVERSE.trouble")})`;

        // Record the preferred rollMode
        options.rollMode = options.rollMode ?? this.options.rollMode;
        return super.toMessage(messageData, options);
    }

    
    /* -------------------------------------------- */
    /** @override */
    evaluate({ minimize = false, maximize = false } = {}) {
        if (this._evaluated) throw new Error("This Roll object has already been rolled.");

        // Step 0 - is this rolling nothing?
        if(this.terms.length == 0) {
            this._evaluated = true;
            this._total = 0;
            return this
        }
        // Step 1 - evaluate any inner Rolls and recompile the formula
        let hasInner = false;
        this.terms = this.terms.map((t) => {
            if (t instanceof MarvelMultiverseRoll) {
                hasInner = true;
                t.evaluate({ minimize, maximize });
                if(t.result === 1){
                    t._total = 6;
                }
                this._dice = this._dice.concat(t.dice);
                return `${t.total}`;
            }
            return t;
        });

        // Step 2 - if inner rolls occurred, re-compile the formula and re-identify terms
        if (hasInner) {
            const formula = this.constructor.cleanFormula(this.terms);
            this.terms = this._identifyTerms(formula);
        }

        // Step 3 - evaluate any remaining terms and return any non-MMRPG dice to the total.
        this.results = this.terms.map((term) => {
            if (!game.system.diceterms.includes(term.constructor)) {
                if (term.evaluate) {
                    if (!(term instanceof OperatorTerm)) this.hasStandard = true;
                    return term.evaluate({ minimize, maximize }).total;
                } else return term;
            } else {
                if (term.evaluate) term.evaluate({ minimize, maximize });
                this.hasMARVEL_MULTIVERSE = true;
                return 0;
            }
        });
        return this;
    }

    //If the main parser hands back a StringTerm attempt to turn it into a die.
    parseShortHand(terms) {
        return terms
        .flatMap(t => {
            if(!(t instanceof StringTerm) || /\d/.test(t.term))
            return t;

            return t.term.replaceAll('d', 'i').split('').reduce((acc, next) => {
            if(next in CONFIG.Dice.terms)
            {
                let cls = CONFIG.Dice.terms[next];
                acc.push(new cls(1));
            }
            else throw new Error(`Unknown die type '${next}'`)

            return acc;
            }, [])
        })
        .flatMap((value, index, array) => //Put addition operators between each die.
            array.length - 1 !== index
            ? [value, new OperatorTerm({operator: '+'})]
            : value)
    }



    /* -------------------------------------------- */
    /*  Configuration Dialog                        */
    /* -------------------------------------------- */

    /**
     * Create a Dialog prompt used to configure evaluation of an existing MarvelMultiverseRoll instance.
     * @param {object} data                     Dialog configuration data
     * @param {string} [data.title]             The title of the shown dialog window
     * @param {number} [data.defaultRollMode]   The roll mode that the roll mode select element should default to
     * @param {number} [data.defaultAction]     The button marked as default
     * @param {boolean} [data.chooseModifier]   Choose which ability modifier should be applied to the roll?
     * @param {string} [data.defaultAbility]    For tool rolls, the default ability modifier applied to the roll
     * @param {string} [data.template]          A custom path to an HTML template to use instead of the default
     * @param {object} options                  Additional Dialog customization options
     * @returns {Promise<MarvelMultiverseRoll|null>}         A resulting MarvelMultiverseRoll object constructed with the dialog, or null if the
     *                                          dialog was closed
     */
    async configureDialog({title, defaultRollMode, defaultAction=MarvelMultiverseRoll.EDGE_MODE.NORMAL, chooseModifier=false,
        defaultAbility, template}={}, options={}) {

        // Render the Dialog inner HTML
        const content = await renderTemplate(template ?? this.constructor.EVALUATION_TEMPLATE, {
            formulas: [{formula: `${this.formula} + @bonus`}],
            defaultRollMode,
            rollModes: CONFIG.Dice.rollModes,
            chooseModifier,
            defaultAbility,
            abilities: CONFIG.MARVEL_MULTIVERSE.abilities
        });

        let defaultButton = "normal";
        switch ( defaultAction ) {
            case MarvelMultiverseRoll.EDGE_MODE.EDGE: defaultButton = "edge"; break;
            case MarvelMultiverseRoll.EDGE_MODE.TROUBLE: defaultButton = "trouble"; break;
        }

        // Create the Dialog window and await submission of the form
        return new Promise(resolve => {
        new Dialog({
            title,
            content,
            buttons: {
            edge: {
                label: game.i18n.localize("MARVEL_MULTIVERSE.edge"),
                callback: html => resolve(this._onDialogSubmit(html, MarvelMultiverseRoll.EDGE_MODE.EDGE))
            },
            normal: {
                label: game.i18n.localize("MARVEL_MULTIVERSE.Normal"),
                callback: html => resolve(this._onDialogSubmit(html, MarvelMultiverseRoll.EDGE_MODE.NORMAL))
            },
            trouble: {
                label: game.i18n.localize("MARVEL_MULTIVERSE.trouble"),
                callback: html => resolve(this._onDialogSubmit(html, MarvelMultiverseRoll.EDGE_MODE.TROUBLE))
            }
            },
            default: defaultButton,
            close: () => resolve(null)
        }, options).render(true);
        });
    }

    /* -------------------------------------------- */

    /**
     * Handle submission of the Roll evaluation configuration Dialog
     * @param {jQuery} html            The submitted dialog content
     * @param {number} edgeMode   The chosen edge mode
     * @returns {MarvelMultiverseRoll}              This damage roll.
     * @private
     */
    _onDialogSubmit(html, edgeMode) {
        const form = html[0].querySelector("form");

        // Append a situational bonus term
        if ( form.bonus.value ) {
            const bonus = new Roll(form.bonus.value, this.data);
            if ( !(bonus.terms[0] instanceof OperatorTerm) ) this.terms.push(new OperatorTerm({operator: "+"}));
            this.terms = this.terms.concat(bonus.terms);
        }

        // Customize the modifier
        if ( form.ability?.value ) {
            const abl = this.data.abilities[form.ability.value];
            this.terms = this.terms.flatMap(t => {
                if ( t.term === "@mod" ) return new NumericTerm({number: abl.value});
                if ( t.term === "@abilityCheckBonus" ) {
                    const bonus = abl.bonuses?.check;
                    if ( bonus ) return new Roll(bonus, this.data).terms;
                    return new NumericTerm({number: 0});
                }
                return t;
            });
            this.options.flavor += ` (${CONFIG.MARVEL_MULTIVERSE.abilities[form.ability.value]?.label ?? ""})`;   
        }

        // Apply advantage or disadvantage
        this.options.advantageMode = advantageMode;
        this.options.rollMode = form.rollMode.value;
        this.configureModifiers();
        return this;
    }
}

// Import document classes.

/* -------------------------------------------- */
/*  Init Hook                                   */
/* -------------------------------------------- */

Hooks.once('init', function () {
  // Add utility classes to the global game object so that they're more easily
  // accessible in global contexts.
  game.MarvelMultiverse = {
    MarvelMultiverseActor,
    MarvelMultiverseItem: MarvelMultiverseItem$1,
    rollItemMacro,
  };

  // Add custom constants for configuration.
  CONFIG.MARVEL_MULTIVERSE = MARVEL_MULTIVERSE$1;

  /**
   * Set an initiative formula for the system
   * @type {String}
   */
  CONFIG.Combat.initiative = {
    formula: '1d20 + @abilities.vig.mod',
    decimals: 2,
  };

  // Define custom Document and DataModel classes
  CONFIG.Actor.documentClass = MarvelMultiverseActor;

  // Note that you don't need to declare a DataModel
  // for the base actor/item classes - they are included
  // with the Character/NPC as part of super.defineSchema()
  CONFIG.Actor.dataModels = {
    character: MarvelMultiverseCharacter,
    npc: MarvelMultiverseNPC
  };
  CONFIG.Item.documentClass = MarvelMultiverseItem$1;
  CONFIG.Item.dataModels = {
    item: MarvelMultiverseItem,
    trait: MarvelMultiverseTrait,
    origin: MarvelMultiverseOrigin,
    occupation: MarvelMultiverseOccupation,
    tag: MarvelMultiverseTag,
    tag: MarvelMultiverseTag,
    power: MarvelMultiversePower
  };

  // Active Effects are never copied to the Actor,
  // but will still apply to the Actor from within the Item
  // if the transfer property on the Active Effect is true.
  CONFIG.ActiveEffect.legacyTransferral = false;


  CONFIG.Dice.types.push(MarvelDie);
  CONFIG.Dice.terms[MarvelDie.DENOMINATION] = MarvelDie;

  CONFIG.Dice.types.push(SixSidedDie);
  CONFIG.Dice.terms[SixSidedDie.DENOMINATION] = SixSidedDie;
  Roll.TOOLTIP_TEMPLATE = "systems/marvel-multiverse/templates/chat/roll-breakdown.hbs";
  CONFIG.Dice.MarvelMultiverseRoll = MarvelMultiverseRoll;

  // Add fonts
  _configureFonts();

  // Register sheet application classes
  Actors.unregisterSheet('core', ActorSheet);
  Actors.registerSheet('marvel-multiverse', MarvelMultiverseActorSheet, {
    makeDefault: true,
    label: 'MARVEL_MULTIVERSE.SheetLabels.Actor',
  });
  Items.unregisterSheet('core', ItemSheet);
  Items.registerSheet('marvel-multiverse', MarvelMultiverseItemSheet, {
    makeDefault: true,
    label: 'MARVEL_MULTIVERSE.SheetLabels.Item',
  });

  // Preload Handlebars templates.
  return preloadHandlebarsTemplates();
});

/* -------------------------------------------- */
/*  Handlebars Helpers                          */
/* -------------------------------------------- */

// If you need to add Handlebars helpers, here is a useful example:
Handlebars.registerHelper('toLowerCase', function (mel) {
  return mel.toLowerCase();
});


/* -------------------------------------------- */

/**
 * Configure additional system fonts.
 */
function _configureFonts() {
  Object.assign(CONFIG.fontDefinitions, {
    Roboto: {
      editor: true,
      fonts: [
        { urls: ["systems/marvel-multiverse/fonts/roboto/Roboto-Regular.woff2"] },
        { urls: ["systems/marvel-multiverse/fonts/roboto/Roboto-Bold.woff2"], weight: "bold" },
        { urls: ["systems/marvel-multiverse/fonts/roboto/Roboto-Italic.woff2"], style: "italic" },
        { urls: ["systems/marvel-multiverse/fonts/roboto/Roboto-BoldItalic.woff2"], weight: "bold", style: "italic" }
      ]
    },
    "Roboto Condensed": {
      editor: true,
      fonts: [
        { urls: ["systems/marvel-multiverse/fonts/roboto-condensed/RobotoCondensed-Regular.woff2"] },
        { urls: ["systems/marvel-multiverse/fonts/roboto-condensed/RobotoCondensed-Bold.woff2"], weight: "bold" },
        { urls: ["systems/marvel-multiverse/fonts/roboto-condensed/RobotoCondensed-Italic.woff2"], style: "italic" },
        {
          urls: ["systems/marvel-multiverse/fonts/roboto-condensed/RobotoCondensed-BoldItalic.woff2"], weight: "bold",
          style: "italic"
        }
      ]
    },
    "Roboto Slab": {
      editor: true,
      fonts: [
        { urls: ["systems/marvel-multiverse/fonts/roboto-slab/RobotoSlab-Regular.ttf"] },
        { urls: ["systems/marvel-multiverse/fonts/roboto-slab/RobotoSlab-Bold.ttf"], weight: "bold" }
      ]
    }
  });
}



/* -------------------------------------------- */
/*  Ready Hook                                  */
/* -------------------------------------------- */

Hooks.once('ready', function () {
  // Wait to register hotbar drop hook on ready so that modules could register earlier if they want to
  Hooks.on('hotbarDrop', (bar, data, slot) => createItemMacro(data, slot));
});

/* -------------------------------------------- */
/*  Hotbar Macros                               */
/* -------------------------------------------- */

/**
 * Create a Macro from an Item drop.
 * Get an existing item macro if one exists, otherwise create a new one.
 * @param {Object} data     The dropped data
 * @param {number} slot     The hotbar slot to use
 * @returns {Promise}
 */
async function createItemMacro(data, slot) {
  // First, determine if this is a valid owned item.
  if (data.type !== 'Item') return;
  if (!data.uuid.includes('Actor.') && !data.uuid.includes('Token.')) {
    return ui.notifications.warn(
      'You can only create macro buttons for owned Items'
    );
  }
  // If it is, retrieve it based on the uuid.
  const item = await Item.fromDropData(data);

  // Create the macro command using the uuid.
  const command = `game.MarvelMultiverse.rollItemMacro("${data.uuid}");`;
  let macro = game.macros.find(
    (m) => m.name === item.name && m.command === command
  );
  if (!macro) {
    macro = await Macro.create({
      name: item.name,
      type: 'script',
      img: item.img,
      command: command,
      flags: { 'marvel-multiverse.itemMacro': true },
    });
  }
  game.user.assignHotbarMacro(macro, slot);
  return false;
}

/**
 * Create a Macro from an Item drop.
 * Get an existing item macro if one exists, otherwise create a new one.
 * @param {string} itemUuid
 */
function rollItemMacro(itemUuid) {
  // Reconstruct the drop data so that we can load the item.
  const dropData = {
    type: 'Item',
    uuid: itemUuid,
  };
  // Load the item from the uuid.
  Item.fromDropData(dropData).then((item) => {
    // Determine if the item loaded and if it's an owned item.
    if (!item || !item.parent) {
      const itemName = item?.name ?? itemUuid;
      return ui.notifications.warn(
        `Could not find item ${itemName}. You may need to delete and recreate this macro.`
      );
    }

    // Trigger the item roll
    item.roll();
  });
}
//# sourceMappingURL=marvel-multiverse-compiled.mjs.map
